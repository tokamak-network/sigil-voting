// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/Groth16Verifier.sol";

/**
 * @title RealProofTest
 * @dev Test with actual ZK proof generated by snarkjs
 *
 * This test verifies that:
 * 1. The Groth16 verifier correctly validates real proofs
 * 2. The circuit implementation matches D1 spec
 * 3. Invalid proofs are rejected
 */
contract RealProofTest is Test {
    Groth16Verifier public verifier;

    // Real proof generated by snarkjs from valid circuit inputs
    // Input: sk=12345, choice=1 (FOR), votingPower=100, proposalId=1
    uint256[2] pA = [
        0x03014ac47cb67d0025c21e778f712ec573e0897164b99719a5f04eecf0a22339,
        0x26bf8cfef29b37c682d0671957625a367552afe7483734b0357aa22a47a205a1
    ];

    uint256[2][2] pB = [
        [
            0x1127b3db2d9ba9f7928625f00961ef652e196100e5be87217d7a539db620ac76,
            0x16ced1be184136e82159027b509f0262b57f52ed624aea4135869ec9bd6afab4
        ],
        [
            0x17ebac7525a6b7de5331260d34d697105fac89be57d3dad3183dbdcbee2d50f3,
            0x0af1301ef48be1565fd3c94d1ac4f616c40e81a56c338c3c098d6d553130adb4
        ]
    ];

    uint256[2] pC = [
        0x2228b7f78784ecb2db8bd55097bb5a250df8918228382c24ddbf0ea030f4ba86,
        0x122560c9bad59f09e611d2925fbdf9049cc73a3c322244d7721466d7010344c2
    ];

    // Public signals (4 as per D1 spec)
    // [voteCommitment, proposalId, votingPower, merkleRoot]
    uint256[4] publicSignals = [
        0x0d365a5ecce6c814b5f372d128ac0ed49b39b0a8b330591407830357a3e33f06, // voteCommitment
        0x0000000000000000000000000000000000000000000000000000000000000001, // proposalId = 1
        0x0000000000000000000000000000000000000000000000000000000000000064, // votingPower = 100
        0x1c0bbccee991ec814e12fbeef40f9dd22d315f1dc21c58b3e1f2cc74d997cbb7  // merkleRoot
    ];

    function setUp() public {
        verifier = new Groth16Verifier();
    }

    function test_RealProofVerification() public view {
        // Verify the real proof
        bool result = verifier.verifyProof(pA, pB, pC, publicSignals);
        assertTrue(result, "Real ZK proof should verify");
    }

    function test_RejectInvalidProof() public view {
        // Modify the proof to make it invalid
        uint256[2] memory invalidPA = pA;
        invalidPA[0] = invalidPA[0] + 1; // Tamper with proof

        bool result = verifier.verifyProof(invalidPA, pB, pC, publicSignals);
        assertFalse(result, "Invalid proof should be rejected");
    }

    function test_RejectWrongPublicSignals() public view {
        // Use wrong public signals
        uint256[4] memory wrongSignals = publicSignals;
        wrongSignals[2] = 200; // Wrong votingPower

        bool result = verifier.verifyProof(pA, pB, pC, wrongSignals);
        assertFalse(result, "Proof with wrong public signals should be rejected");
    }

    function test_PublicSignalsMatchD1Spec() public view {
        // Verify the 4 public signals structure matches D1 spec
        // Signal 0: voteCommitment = hash(choice, votingPower, proposalId, voteSalt)
        // Signal 1: proposalId
        // Signal 2: votingPower
        // Signal 3: merkleRoot

        uint256 proposalId = publicSignals[1];
        uint256 votingPower = publicSignals[2];

        assertEq(proposalId, 1, "proposalId should be 1");
        assertEq(votingPower, 100, "votingPower should be 100");
    }
}
