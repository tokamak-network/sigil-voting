// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/Groth16Verifier.sol";

/**
 * @title RealProofTest
 * @dev Test with actual ZK proof generated by snarkjs
 *
 * This test verifies that:
 * 1. The Groth16 verifier correctly validates real proofs
 * 2. The circuit implementation matches D1 spec
 * 3. Invalid proofs are rejected
 */
contract RealProofTest is Test {
    Groth16Verifier public verifier;

    // Real proof generated by snarkjs from valid circuit inputs
    // Input: sk=12345, choice=1 (FOR), votingPower=100, proposalId=1
    uint256[2] pA = [
        0x248271760d4f3fc718942cf4ac0889097d113e5c860607abbad54640fc4fabe4,
        0x0575748bfcddbb9da134caffd1ab22aac448d698e0e1541c14cbf877d26767d1
    ];

    uint256[2][2] pB = [
        [
            0x1b28fab7ff9eec7fff303f5eca515f8ace1827d7d148a14212e2cfd058c3fb7e,
            0x0352ad836dc7fd1440a347b3793ea05ef14a43bf8c09c9ac6c0a814e93e6d0d3
        ],
        [
            0x1b78f397d513792a155690cac39851f3f415afc66e7e863285cd78d448356f88,
            0x135f2edcf56a30c5381a76b7675e9a1b2efe8053448b6b25d106e75291aa3df9
        ]
    ];

    uint256[2] pC = [
        0x229b34d6d06eeeaa467e99f6de2d2c5420350a97859d1f905de0586bb574d23c,
        0x16d39f17b5c9db36e38bf2ebbee5d5c99ee43baf588174c90d3b32fa1aee428c
    ];

    // Public signals (5): [nullifier, voteCommitment, proposalId, votingPower, merkleRoot]
    // Note: snarkjs outputs come first, then inputs
    uint256[5] publicSignals = [
        0x0950acb7e532ebb21176a28dee52617a5a37ce9294aab1cf603024e5b9063f9a, // nullifier
        0x0f7d89be02493d7bd2db3d5f54c60731c5ed548631a8bd427f7e8f88f87bee6d, // voteCommitment
        0x0000000000000000000000000000000000000000000000000000000000000001, // proposalId = 1
        0x0000000000000000000000000000000000000000000000000000000000000064, // votingPower = 100
        0x0d1551f9a07f0b9c21c747bb587b9e4c741ba79be587a8ca63cd2ba1f75462a0  // merkleRoot
    ];

    function setUp() public {
        verifier = new Groth16Verifier();
    }

    function test_RealProofVerification() public view {
        // Verify the real proof
        bool result = verifier.verifyProof(pA, pB, pC, publicSignals);
        assertTrue(result, "Real ZK proof should verify");
    }

    function test_RejectInvalidProof() public view {
        // Modify the proof to make it invalid
        uint256[2] memory invalidPA = pA;
        invalidPA[0] = invalidPA[0] + 1; // Tamper with proof

        bool result = verifier.verifyProof(invalidPA, pB, pC, publicSignals);
        assertFalse(result, "Invalid proof should be rejected");
    }

    function test_RejectWrongPublicSignals() public view {
        // Use wrong public signals
        uint256[5] memory wrongSignals = publicSignals;
        wrongSignals[3] = 200; // Wrong votingPower (index 3)

        bool result = verifier.verifyProof(pA, pB, pC, wrongSignals);
        assertFalse(result, "Proof with wrong public signals should be rejected");
    }

    function test_PublicSignalsMatchD1Spec() public view {
        // Verify the 5 public signals structure
        // Signal order (snarkjs): outputs first, then inputs
        // Signal 0: nullifier = hash(sk, proposalId)
        // Signal 1: voteCommitment = hash(choice, votingPower, proposalId, voteSalt)
        // Signal 2: proposalId
        // Signal 3: votingPower
        // Signal 4: merkleRoot

        uint256 proposalId = publicSignals[2];
        uint256 votingPower = publicSignals[3];

        assertEq(proposalId, 1, "proposalId should be 1");
        assertEq(votingPower, 100, "votingPower should be 100");
    }
}
